#!/bin/bash

cd ~/Desktop/Fast-Downward

# Download and install FF Planner
wget https://fai.cs.uni-saarland.de/hoffmann/ff/Metric-FF.tgz
gunzip Metric-FF.tgz
tar -xvf Metric-FF.tar
mv Metric-FF FF

cd FF
make

# Setup Lab Files
touch ff.py
touch ff-parser.py

printf "#! /usr/bin/env python\n\nimport os\nimport platform\n\nfrom downward import suites\nfrom downward.reports.absolute import AbsoluteReport\nfrom lab.environments import BaselSlurmEnvironment, LocalEnvironment\nfrom lab.experiment import Experiment\nfrom lab.reports import Attribute, geometric_mean\n\n\n# Create custom report class with suitable info and error attributes.\nclass BaseReport(AbsoluteReport):\n    INFO_ATTRIBUTES = [\"time_limit\", \"memory_limit\"]\n    ERROR_ATTRIBUTES = [\n        \"domain\",\n        \"problem\",\n        \"algorithm\",\n        \"unexplained_errors\",\n        \"error\",\n        \"node\",\n    ]\n\n\nNODE = platform.node()\nREMOTE = NODE.endswith(\n    \".scicore.unibas.ch\") or NODE.endswith(\".cluster.bc2.ch\")\nBENCHMARKS_DIR = os.environ[\"DOWNWARD_BENCHMARKS\"]\nSIMULATION_DIR = os.environ[\"SIMULATION_PDDL\"]\nif REMOTE:\n    ENV = BaselSlurmEnvironment(email=\"my.name@unibas.ch\")\nelse:\n    ENV = LocalEnvironment(processes=2)\nSUITE = [\"grid\", \"gripper:prob01.pddl\",\n         \"miconic:s1-0.pddl\", \"mystery:prob07.pddl\"]\nATTRIBUTES = [\n    \"error\",\n    \"plan\",\n    \"times\",\n    Attribute(\"coverage\", absolute=True, min_wins=False, scale=\"linear\"),\n    Attribute(\"evaluations\", function=geometric_mean),\n    Attribute(\"trivially_unsolvable\", min_wins=False),\n]\nTIME_LIMIT = 1800\nMEMORY_LIMIT = 2048\n\n\n# Create a new experiment.\nexp = Experiment(environment=ENV)\n# Add custom parser for FF.\nexp.add_parser(\"ff-parser.py\")\n\nfor task in suites.build_suite(BENCHMARKS_DIR, SUITE):\n    run = exp.add_run()\n    # Create symbolic links and aliases. This is optional. We\n    # could also use absolute paths in add_command().\n    run.add_resource(\"domain\", task.domain_file, symlink=True)\n    run.add_resource(\"problem\", task.problem_file, symlink=True)\n    # 'ff' binary has to be on the PATH.\n    # We could also use exp.add_resource().\n    run.add_command(\n        \"run-planner\",\n        [\"ff\", \"-o\", \"{domain}\", \"-f\", \"{problem}\"],\n        time_limit=TIME_LIMIT,\n        memory_limit=MEMORY_LIMIT,\n    )\n    # AbsoluteReport needs the following properties:\n    # 'domain', 'problem', 'algorithm', 'coverage'.\n    run.set_property(\"domain\", task.domain)\n    run.set_property(\"problem\", task.problem)\n    run.set_property(\"algorithm\", \"ff\")\n    # BaseReport needs the following properties:\n    # 'time_limit', 'memory_limit'.\n    run.set_property(\"time_limit\", TIME_LIMIT)\n    run.set_property(\"memory_limit\", MEMORY_LIMIT)\n    # Every run has to have a unique id in the form of a list.\n    # The algorithm name is only really needed when there are\n    # multiple algorithms.\n    run.set_property(\"id\", [\"ff\", task.domain, task.problem])\n\n# Add step that writes experiment files to disk.\nexp.add_step(\"build\", exp.build)\n\n# Add step that executes all runs.\nexp.add_step(\"start\", exp.start_runs)\n\n# Add step that collects properties from run directories and\n# writes them to *-eval/properties.\nexp.add_fetcher(name=\"fetch\")\n\n# Make a report.\nexp.add_report(BaseReport(attributes=ATTRIBUTES), outfile=\"report.html\")\n\n# Parse the commandline and run the specified steps.\nexp.run_steps()\n" >> ff.py
printf "#! /usr/bin/env python\n\nimport re\n\nfrom lab.parser import Parser\n\n\ndef error(content, props):\n    if props[\"planner_exit_code\"] == 0:\n        props[\"error\"] = \"plan-found\"\n    else:\n        props[\"error\"] = \"unsolvable-or-error\"\n\n\ndef coverage(content, props):\n    props[\"coverage\"] = int(props[\"planner_exit_code\"] == 0)\n\n\ndef get_plan(content, props):\n    # All patterns are parsed before functions are called.\n    if props.get(\"evaluations\") is not None:\n        props[\"plan\"] = re.findall(r\"^(?:step)?\s*\d+: (.+)\$\", content, re.M)\n\n\ndef get_times(content, props):\n    props[\"times\"] = re.findall(r\"(\d+\.\d+) seconds\", content)\n\n\ndef trivially_unsolvable(content, props):\n    props[\"trivially_unsolvable\"] = int(\n        \"ff: goal can be simplified to FALSE. No plan will solve it\" in content\n    )\n\n\nparser = Parser()\nparser.add_pattern(\"node\", r\"node: (.+)\n\", type=str,\n                   file=\"driver.log\", required=True)\nparser.add_pattern(\n    \"planner_exit_code\", r\"run-planner exit code: (.+)\n\", type=int, file=\"driver.log\"\n)\nparser.add_pattern(\"evaluations\", r\"evaluating (\d+) states\")\nparser.add_function(error)\nparser.add_function(coverage)\nparser.add_function(get_plan)\nparser.add_function(get_times)\nparser.add_function(trivially_unsolvable)\nparser.parse()\n" >> ff-parser.py

# Cleanup
cd ..
rm -r Metric-FF.tar

echo 'Run experiments with the file ff.py'
